Introduction to R, Day 2
========================================================
author: Thomas Carroll
date: 
css:style.css
autosize:true
autosize:true
Recap -- 
========================================================

Control Structure and Loops
========================================================
We have looked at using logical vectors as a versatile way to index other data types
```{r}
x <- 1:10
x[x < 4]
```

Logicals have an important part in controlling how scripted procedures execute.


Two important control structures
========

- Conditional branching (if,else ifelse)
- Loops (for, while, switch)

**While** I'm analysing data, **if** I need to execute complex statistical procedures on the data I will use R **else** I will use a calculator.

Conditional Branching.
========

Conditional Branching is evaluation of a logical to determine whether a procedure is executed.

In the R we use the **if** statement with the logical to be evaluated in **()** and dependent statement to executed in **{}**.

```{r,message=T}
x <- T
x
if(x){
  message("x is true")
}
x <- F
x
if(x){
  message("x is true")
}

```
Evaluating in if() statments
====

More often, we construct the logical value within **()** itself.

```{r,message=T}
x <- 10
y <- 4
x > y

if(x > y){
  message("The value of x is ",x," is greater than ", y)
}
```
Here the message is printed because x is greater than y. 
```{r,message=T}

y <- 20
if(x > y){
  message("The value of x is ",x," is greater than ", y)
}



```
Here, x is not longer greater than y so no message is printed.

We really still want a message telling us what was the result of the comparison even if it didn't pass criteria

else following an if().
========================

If we want to perform an operation when the condition is false we can follow the if() statement with an else statement.

```{r,message=T}
x < - 10
if(x < 5){
  message(x, " is less than to 5")
   }else{
     message(x," is greater than or equal to 5")
}
x <- 3
if(x < 5){
  message(x, " is less than 5")
   }else{
     message(x," is greater than or equal to 5")
}

```



ifelse()
===========

We may wish to execute different procedures under multiple conditions. This can be control in R using the else if() following an initial if() statement.
```{r}
x <- 5
if(x > 5){
  message(x," is greater than 5")
  }else if(x == 5){
    message(x," is 5")
  }else{
    message(x, " is less than 5")
  }
```

elseif()
======

A useful function to evaluate condition statements over vectors is the ifelse() function.

```{r}
x <- 1:10
message(x)
```

The ifelse() functions take the arguments of the condition to evaluate, the action if the condition is true and the action when condition is false.

```{r}
ifelse(x <= 3,"lessOrEqual","more") 
```

This allows for multiple nested else if statements to be applied to vectors.

```{r}
ifelse(x == 3,"same",
       ifelse(x < 3,"less","more")
       ) 
```
Loops
======

The two main generic methods of looping in R are **while** and **for**

- **while** - *while* loops repeat the execution of code while a condition evaluates as false.

- **for** - *for* loops repeat the execution of code for a range of specified values.

While loops
=====

While loops are most useful if you know the condition will be satisified but are not sure when. (i.e. Looking for a when a number first occurs in a list).
```{r}
i <- 0
x <- 1
while(x != 3){
  message(x[i])
  x <- x+1
}
message("Finally x is 3")
```

For loops
=====


For loops allow the user to cycle through a range of values applying an operation for every value.
.
Here we cycle through x and print out its value
```{r}
x <- 1:10
for(i in x){
  message(i)
}
```


Looping through indices
=====

In sme occasions we may wish to keep track of the position in x we are evaluating. A common pactice is loop though all possible index positions of x using the expression **1:length(x)**.

```{r,message=T}
x <- sample(1:24,5)
y <- letters
1:length(x)

for(i in 1:length(x)){
  message("Number ",i," in x is ",x[i])
  message("Letter ",i," in the alphabet is ",y[i]) 
}
```

Loops and conditionals
=======================

Loops can be combined with conditional statements to allow for complex control of their execution over R objects. 

```{r}
x <- 1:13

for(i in 1:13){
  if(i > 10){
    message("Number ",i," is greater than 10")
  }else if(i == 10){
    message("Number ",i," is  10") 
  }else{
    message("Number ",i," is less than  10") 
  }
}
```

Breaking loops
=====

We can use conditionals to exit a loop if a condition is satisfied, just a while loop.

```{r,message=T}
x <- 1:13

for(i in 1:13){
  if(i < 10){
    message("Number ",i," is less than 10")
  }else if(i == 10){
    message("Number ",i," is  10")
    break
  }else{
    message("Number ",i," is greater than  10") 
  }
}
```

Functions
===

As we have seen, a function is command which require one or more arguments and returns a single R object. 

This allows for the user to perform complex calculations and prodecures with one simple operation.

```{r,message=T}
x=rnorm(100,70,10)
y <- jitter(x,amount=1)+20
mean(x)

lmExample <- data.frame(X=x,Y=y)
lmResult <- lm(Y~X,data=lmExample)
```
***
```{r,message=T}
plot(Y~X,data=lmExample,main="Line of best fit with lm()",
     xlim=c(0,150),ylim=c(0,150))
abline(lmResult,col="red",lty=3,lwd=3)
```


Defining your own functions
======

Although we have access to many built functions in R, there will be many complex tasks we wish to perform regularly which are particular to our own work and for which no suitable function exists. 

For these tasks we can construct your own functions with **function()**

To define a function we need to define 
- the argument names within **()**
- the expression to be evaluated within **{}** 
- the variable the function will be assigned to with **<-**.
- the data that should be output from the function using **return()** 

**Function_name** <- function(**Argument1**,**Argument2**){ **Expression**}

```{r,message=T}
myFirstFunction <- function(myArgument1,myArgument2){
  myResult <- (myArgument1*myArgument2)
  return(myResult)
}
myFirstFunction(4,5)
```

User functions extend the
capabilities of R by adapting or creating new tasks that are tailored
to your specific requirements.

Default arguments
====

In some functions a default value for an argument may be used.
This allows the function to provide a value for an argument when the user does not specify one.

Default arguments can be specified by assigning a value
```{r,message=T}

mySecondFunction <- function(myArgument1,myArgument2=10){
  myResult <- (myArgument1*myArgument2)
  return(myResult)
}
mySecondFunction(4,5)
mySecondFunction(4)
```


Missing Arguments
====

In some cases a function may wish to deal with missing arguments in a different way to setting a generic default for the argument. The missing() function can be used to evaluate whether an argument has been defined 

```{r,message=T}

mySecondFunction <- function(myArgument1,myArgument2){
  if(missing(myArgument2)){
    message("Value for myArgument2 not provided so will square myArgument1")
    myResult <- myArgument1*myArgument1
  }else{
    myResult <- (myArgument1*myArgument2)   
  }
  return(myResult)
}
mySecondFunction(4,5)
mySecondFunction(4)
```


Returning objects from functions
====

We have seen a function returns the value within the return() function.If no return is specified, the result of last line evaluated in the function.

```{r,message=T}
myforthFunction <- function(myArgument1,myArgument2=10){
  myResult <- (myArgument1*myArgument2)
  return(myResult)
  print("I returned the result")
}
myfifthFunction <- function(myArgument1,myArgument2=10){
(myArgument1*myArgument2)
}

myforthFunction(4,5)
myfifthFunction(4,5)

```

Note that the print() statment after the return() is not evaluated in myforthFuntion.

Returning lists from functions
====

The return() function can only return one R object at a time. To return multiple data objects from one function call, a list can be used to contain other data objects.

```{r,message=T}
mySixFunction <- function(arg1,arg2){
  result1 <- arg1*arg2
  result2 <- date()
  return(list(Calculation=result1,DateRun=result2))
}
result <- mySixFunction(10,10)

result
c(class(result$Calculation),class(result$DateRun))
```

====

If we want to return a mix of different data types back from a function, we will use a list.


Its a good idea to have some simple checking of the arguments you have.
A useful function pt

Defining functions can
- Make code more accessible.
- Streamline repetitive tasks.
- Increase reproducibility. 



Easy to read
x <- 1:40
y <- 5:35

Harder to read



Some tips for speed comparisons..


Getting help

